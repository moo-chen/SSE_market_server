Index: config/application.yml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># 配置文件\r\nserver:\r\n# 监听端口号，默认8080\r\n  port:8080\r\n#数据库配置\r\ndatasource:\r\n  driverName: mysql\r\n  host: 127.0.0.1\r\n  port: 3306\r\n  #数据库名称\r\n  database: ssemarket\r\n  username: root\r\n  #密码\r\n  password: '0527'\r\n  charset: utf8mb4
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/config/application.yml b/config/application.yml
--- a/config/application.yml	(revision 5afa5a6d29d7597b4b40ddaafe3526ac57919d83)
+++ b/config/application.yml	(date 1684501197061)
@@ -8,7 +8,7 @@
   host: 127.0.0.1
   port: 3306
   #数据库名称
-  database: ssemarket
+  database: ssemarket1
   username: root
   #密码
   password: '0527'
Index: middleware/authMiddleware.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// 返回token中间件，不用管，要看也行。模板写法来着，至于为什么，我也不是很懂\r\npackage middleware\r\n\r\nimport (\r\n\t\"github.com/gin-gonic/gin\"\r\n\t\"loginTest/common\"\r\n\t\"loginTest/model\"\r\n\t\"net/http\"\r\n\t\"strings\"\r\n)\r\n\r\nfunc AuthMiddleware() gin.HandlerFunc {\r\n\treturn func(ctx *gin.Context) {\r\n\t\t//获取authorization header\r\n\t\ttokenString := ctx.GetHeader(\"Authorization\")\r\n\t\t//若token为空或token格式不正确\r\n\t\tif tokenString == \"\" || !strings.HasPrefix(tokenString, \"Bearer\") {\r\n\t\t\tctx.JSON(http.StatusUnauthorized, gin.H{\"code\": 401, \"msg\": \"权限不足: 100}\"})\r\n\t\t\tctx.Abort()\r\n\t\t\treturn\r\n\t\t}\r\n\t\ttokenString = tokenString[7:]\r\n\t\ttoken, claims, err := common.ParseToken(tokenString)\r\n\t\tif err != nil || !token.Valid {\r\n\t\t\tctx.JSON(http.StatusUnauthorized, gin.H{\"code\": 401, \"msg\": \"权限不足: 200}}\"})\r\n\t\t\tctx.Abort()\r\n\t\t\treturn\r\n\t\t}\r\n\t\t//验证通过后获取claims中的userId\r\n\t\tuserId := claims.UserID\r\n\t\tif userId == 0 {\r\n\t\t\tctx.JSON(http.StatusUnauthorized, gin.H{\"code\": 401, \"msg\": \"权限不足:301\"})\r\n\t\t\tctx.Abort()\r\n\t\t\treturn\r\n\t\t}\r\n\t\tdb := common.GetDB()\r\n\t\tuser := model.User{}\r\n\t\tdb.Where(\"userID = ?\", userId).First(&user)\r\n\t\t//用户不存在\r\n\t\tif user.UserID == 0 {\r\n\t\t\tctx.JSON(http.StatusUnauthorized, gin.H{\"code\": 401, \"msg\": \"权限不足:302\"})\r\n\t\t\tctx.Abort()\r\n\t\t\treturn\r\n\t\t}\r\n\t\t//用户存在，将user的信息写入上下文\r\n\t\tctx.Set(\"user\", user)\r\n\t\tctx.Next()\r\n\t}\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/middleware/authMiddleware.go b/middleware/authMiddleware.go
--- a/middleware/authMiddleware.go	(revision 5afa5a6d29d7597b4b40ddaafe3526ac57919d83)
+++ b/middleware/authMiddleware.go	(date 1685119987193)
@@ -21,15 +21,20 @@
 		}
 		tokenString = tokenString[7:]
 		token, claims, err := common.ParseToken(tokenString)
-		if err != nil || !token.Valid {
-			ctx.JSON(http.StatusUnauthorized, gin.H{"code": 401, "msg": "权限不足: 200}}"})
+		if err != nil {
+			ctx.JSON(http.StatusUnauthorized, gin.H{"code": 401, "msg": "权限不足: 200 " + err.Error()})
+			ctx.Abort()
+			return
+		}
+		if !token.Valid {
+			ctx.JSON(http.StatusUnauthorized, gin.H{"code": 401, "msg": "权限不足: 201,令牌无效"})
 			ctx.Abort()
 			return
 		}
 		//验证通过后获取claims中的userId
 		userId := claims.UserID
 		if userId == 0 {
-			ctx.JSON(http.StatusUnauthorized, gin.H{"code": 401, "msg": "权限不足:301"})
+			ctx.JSON(http.StatusUnauthorized, gin.H{"code": 402, "msg": "权限不足:301"})
 			ctx.Abort()
 			return
 		}
Index: common/jwt.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// 返回token的文件，不用管，要看也行。模板写法来着，至于为什么，我也不是很懂\r\npackage common\r\n\r\nimport (\r\n\t\"github.com/dgrijalva/jwt-go\"\r\n\t\"loginTest/model\"\r\n\t\"time\"\r\n)\r\n\r\n// 采用jwt方式生成token\r\nvar jwtKey = []byte(\"a_secret_crect\")\r\n\r\ntype Claims struct {\r\n\tUserID int\r\n\tjwt.StandardClaims\r\n}\r\n\r\nfunc ReleaseToken(user model.User) (string, error) {\r\n\texpirationTime := time.Now().Add(7 * 24 * time.Hour)\r\n\tclaims := &Claims{\r\n\t\tUserID: user.UserID,\r\n\t\tStandardClaims: jwt.StandardClaims{\r\n\t\t\tExpiresAt: expirationTime.Unix(),\r\n\t\t\tIssuedAt:  time.Now().Unix(),\r\n\t\t\tIssuer:    \"loginTest\",\r\n\t\t\tSubject:   \"user token\",\r\n\t\t},\r\n\t}\r\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\r\n\ttokenString, err := token.SignedString(jwtKey)\r\n\tif err != nil {\r\n\t\treturn \"\", err\r\n\t}\r\n\treturn tokenString, nil\r\n}\r\n\r\nfunc ParseToken(tokenString string) (*jwt.Token, *Claims, error) {\r\n\tclaims := &Claims{}\r\n\ttoken, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (i interface{}, err error) {\r\n\t\treturn jwtKey, nil\r\n\t})\r\n\treturn token, claims, err\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/jwt.go b/common/jwt.go
--- a/common/jwt.go	(revision 5afa5a6d29d7597b4b40ddaafe3526ac57919d83)
+++ b/common/jwt.go	(date 1685101942895)
@@ -16,7 +16,7 @@
 }
 
 func ReleaseToken(user model.User) (string, error) {
-	expirationTime := time.Now().Add(7 * 24 * time.Hour)
+	expirationTime := time.Now().Add(1 * time.Second)
 	claims := &Claims{
 		UserID: user.UserID,
 		StandardClaims: jwt.StandardClaims{
